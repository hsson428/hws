#### 1. Built-in 함수와 메서드

​	**sorted()**와 **.sort()**의 차이점을 코드의 실행 결과를 활용하여 설명하시오.

```python
l = [3, 2, 1]
print(sorted(l))	# [1, 2, 3]
print(l)			# [3, 2, 1]
l.sort()
print(l)			# [1, 2, 3]
```



#### 2. .extend()와 .append

​	**.extend()**와 **.append()**의 차이점을 코드의 실행 결과를 활용하여 설명하시오.

```python
l = ['11']
l.append('22')
print(l)	# ['11', '22']
l.extend('33')
print(l)	# ['11', '22', '3', '3']

l.append(['44', '55'])
print(l)	# ['11', '22', '3', '3', ['44', '55']]
l.extend(['55', '66'])
print(l)	# ['11', '22', '3', '3', ['44', '55'], '66', '77']
```



#### 3. 복사가 잘 된 건가?

​	아래의 코드를 실행 하였을 때, 변수 a와 b에 담긴 list의 요소가 같은지 혹은 다른지 여부를 판	단하고 그 이유를 작성하시오.

```python
a = [1, 2, 3, 4, 5]
b = a

a[2] = 5

print(a)	# [1, 2, 5, 4, 5]
print(b)	# [1, 2, 5, 4, 5]
# 같다.
# 같은 주솟값을 참조했기 때문에 둘 중 하나만 변경하면 다른 하나도 같이 바뀐다.

# 다른 방법으로는
1차원 리스트인 경우 얕은 복사(shallow copy)로 가능
b = a[:]
import copy
b = copy.copy(a)
하지만 mutable객체 안에 mutable객체인 경우 문제가 됨
리스트 안에 또 리스트가 있을 경우 내부 리스트는 같은 객체값을 참조

따라서 2차원 이상인 경우 깊은 복사(deep copy)로 가능하다
import copy
b = copy.deepcopy(a)
```

​	